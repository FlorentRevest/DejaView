// AUTOGENERATED - DO NOT EDIT
// ---------------------------
// This file has been generated by
// AOSP://external/dejaview/tools/gen_merged_protos
// merging the dejaview config protos.
// This fused proto is intended to be copied in:
//  - Android tree, for statsd.
//  - Google internal repos.

syntax = "proto2";

package dejaview.protos;

option go_package = "github.com/google/perfetto/dejaview_proto";

// Begin of protos/dejaview/common/track_event_descriptor.proto

message TrackEventCategory {
  optional string name = 1;
  optional string description = 2;
  repeated string tags = 3;
}

message TrackEventDescriptor {
  repeated TrackEventCategory available_categories = 1;
}

// End of protos/dejaview/common/track_event_descriptor.proto

// Begin of protos/dejaview/common/data_source_descriptor.proto

// This message is sent from Producer(s) to the tracing Service when registering
// to advertise their capabilities. It describes the structure of tracing
// protos that will be produced by the data source and the supported filters.
message DataSourceDescriptor {
  // e.g., "linux.ftrace", "chromium.tracing"
  optional string name = 1;

  // When non-zero, this is a unique ID within the scope of the Producer for
  // this data source (it is NOT globally unique). This is useful to
  // differentiate between data sources with matching names when calling
  // UpdateDataSource(). This field has been introduced in November 2021
  // (v22, Android T) and is not supported on older versions.
  optional uint64 id = 7;

  // When true the data source is expected to ack the stop request through the
  // NotifyDataSourceStopped() IPC. This field has been introduced after
  // Android P in Jul 2018 and is not supported on older versions.
  optional bool will_notify_on_stop = 2;

  // When true the data source is expected to ack the start request through the
  // NotifyDataSourceStarted() IPC. This field has been introduced after
  // Android P in March 2019 and is not supported on older versions.
  optional bool will_notify_on_start = 3;

  // If true, opt into receiving the ClearIncrementalState() IPC. This should be
  // set if the data source writes packets that refer to previous trace
  // contents, and knows how to stop referring to the already-emitted data.
  optional bool handles_incremental_state_clear = 4;

  // If true, indicates that the data source does nothing upon Flush. This
  // allows the service to reduce the flush-related IPC traffic and better deal
  // with frozen producers (see go/perfetto-frozen). This is usually the case
  // for data sources like 'track_event' that don't have access to the various
  // thread task runners to post a flush task and rely purely on server-side
  // scraping.
  // Introduced in v39 / Android V.
  optional bool no_flush = 9;

  optional TrackEventDescriptor track_event_descriptor = 6 [lazy = true];
}

// End of protos/dejaview/common/data_source_descriptor.proto

// Begin of protos/dejaview/common/tracing_service_state.proto

// Reports the state of the tracing service. Used to gather details about the
// data sources connected.
// See ConsumerPort::QueryServiceState().
message TracingServiceState {
  // Describes a producer process.
  message Producer {
    // Unique ID of the producer (monotonic counter).
    optional int32 id = 1;

    // Typically matches the process name.
    optional string name = 2;

    // Unix pid of the remote process. Supported only on Linux-based systems.
    // Introduced in v24 / Android T.
    optional int32 pid = 5;

    // Unix uid of the remote process.
    optional int32 uid = 3;

    // The version of the client library used by the producer.
    // This is a human readable string with and its format varies depending on
    // the build system and the repo (standalone vs AOSP).
    // This is intended for human debugging only.
    optional string sdk_version = 4;
  }

  // Describes a data source registered by a producer. Data sources are listed
  // regardless of the fact that they are being used or not.
  message DataSource {
    // Descriptor passed by the data source when calling RegisterDataSource().
    optional DataSourceDescriptor ds_descriptor = 1;

    // ID of the producer, as per Producer.id.
    optional int32 producer_id = 2;
  }

  message TracingSession {
    // The TracingSessionID.
    optional uint64 id = 1;

    // The Unix uid of the consumer that started the session.
    // This is meaningful only if the caller is root. In all other cases only
    // tracing sessions that match the caller UID will be displayed.
    optional int32 consumer_uid = 2;

    // Internal state of the tracing session.
    // These strings are FYI only and subjected to change.
    optional string state = 3;

    // The unique_session_name as set in the trace config (might be empty).
    optional string unique_session_name = 4;

    // The number and size of each buffer.
    repeated uint32 buffer_size_kb = 5;

    // Duration, as specified in the TraceConfig.duration_ms.
    optional uint32 duration_ms = 6;

    // Number of data sources involved in the session.
    optional uint32 num_data_sources = 7;

    // Time when the session was started, in the CLOCK_REALTIME domain.
    // Available only on Linux-based systems.
    optional int64 start_realtime_ns = 8;

    // The fields below have been introduced in v42.

    // The bugreport_score, as set in TraceConfig.bugreport_score.
    optional int32 bugreport_score = 9;

    // As per TraceConfig.bugreport_filename.
    optional string bugreport_filename = 10;

    // If true, the session is in the STARTED state. If false the session is in
    // any other state (see `state` field).
    optional bool is_started = 11;
  }

  // Lists all the producers connected.
  repeated Producer producers = 1;

  // Lists the data sources available.
  repeated DataSource data_sources = 2;

  // Lists the tracing sessions active AND owned by a consumer that has the same
  // UID of the caller (or all of them if the caller is root).
  // Introduced in v24 / Android T.
  repeated TracingSession tracing_sessions = 6;

  // This is always set to true from v24 and beyond. This flag is only used to
  // tell the difference between: (1) talking to a recent service which happens
  // to have no tracing session active; (2) talking to an older version of the
  // service which will never report any tracing session.
  optional bool supports_tracing_sessions = 7;

  // Total number of tracing sessions.
  optional int32 num_sessions = 3;

  // Number of tracing sessions in the started state. Always <= num_sessions.
  optional int32 num_sessions_started = 4;

  // The version of traced (the same returned by `traced --version`).
  // This is a human readable string with and its format varies depending on
  // the build system and the repo (standalone vs AOSP).
  // This is intended for human debugging only.
  optional string tracing_service_version = 5;
}

// End of protos/dejaview/common/tracing_service_state.proto

// Begin of protos/dejaview/common/builtin_clock.proto

enum BuiltinClock {
  BUILTIN_CLOCK_UNKNOWN = 0;
  BUILTIN_CLOCK_REALTIME = 1;
  BUILTIN_CLOCK_REALTIME_COARSE = 2;
  BUILTIN_CLOCK_MONOTONIC = 3;
  BUILTIN_CLOCK_MONOTONIC_COARSE = 4;
  BUILTIN_CLOCK_MONOTONIC_RAW = 5;
  BUILTIN_CLOCK_BOOTTIME = 6;
  BUILTIN_CLOCK_TSC = 9;
  BUILTIN_CLOCK_PERF = 10;
  BUILTIN_CLOCK_MAX_ID = 63;

  reserved 7, 8;
}

// End of protos/dejaview/common/builtin_clock.proto

// Begin of protos/dejaview/config/inode_file/inode_file_config.proto

message InodeFileConfig {
  message MountPointMappingEntry {
    optional string mountpoint = 1;
    repeated string scan_roots = 2;
  }

  // How long to pause between batches.
  optional uint32 scan_interval_ms = 1;

  // How long to wait before the first scan in order to accumulate inodes.
  optional uint32 scan_delay_ms = 2;

  // How many inodes to scan in one batch.
  optional uint32 scan_batch_size = 3;

  // Do not scan for inodes not found in the static map.
  optional bool do_not_scan = 4;

  // If non-empty, only scan inodes corresponding to block devices named in
  // this list.
  repeated string scan_mount_points = 5;

  // When encountering an inode belonging to a block device corresponding
  // to one of the mount points in this map, scan its scan_roots instead.
  repeated MountPointMappingEntry mount_point_mapping = 6;
}

// End of protos/dejaview/config/inode_file/inode_file_config.proto

// Begin of protos/dejaview/config/interceptors/console_config.proto

message ConsoleConfig {
  enum Output {
    OUTPUT_UNSPECIFIED = 0;
    OUTPUT_STDOUT = 1;
    OUTPUT_STDERR = 2;
  }
  optional Output output = 1;
  optional bool enable_colors = 2;
}

// End of protos/dejaview/config/interceptors/console_config.proto

// Begin of protos/dejaview/config/interceptor_config.proto

// Configuration for trace packet interception. Used for diverting trace data to
// non-DejaView sources (e.g., logging to the console, ETW) when using the
// DejaView SDK.
message InterceptorConfig {
  // Matches the name given to RegisterInterceptor().
  optional string name = 1;

  optional ConsoleConfig console_config = 100;
}

// End of protos/dejaview/config/interceptor_config.proto

// Begin of protos/dejaview/config/process_stats/process_stats_config.proto

message ProcessStatsConfig {
  enum Quirks {
    QUIRKS_UNSPECIFIED = 0;

    // This has been deprecated and ignored as per 2018-05-01. Full scan at
    // startup is now disabled by default and can be re-enabled using the
    // |scan_all_processes_on_start| arg.
    DISABLE_INITIAL_DUMP = 1 [deprecated = true];

    DISABLE_ON_DEMAND = 2;
  }
  repeated Quirks quirks = 1;

  // If enabled all processes will be scanned and dumped when the trace starts.
  optional bool scan_all_processes_on_start = 2;

  // If enabled thread names are also recoded (this is redundant if sched_switch
  // is enabled).
  optional bool record_thread_names = 3;

  // If > 0 samples counters (see process_stats.proto) from
  // /proc/pid/status and oom_score_adj every X ms.
  // It will also sample /proc/pid/smaps_rollup if scan_smaps_rollup = true.
  // This is required to be > 100ms to avoid excessive CPU usage.
  optional uint32 proc_stats_poll_ms = 4;

  // id 5 never used

  // This is required to be either = 0 or a multiple of |proc_stats_poll_ms|
  // (default: |proc_stats_poll_ms|). If = 0, will be set to
  // |proc_stats_poll_ms|. Non-multiples will be rounded down to the nearest
  // multiple.
  optional uint32 proc_stats_cache_ttl_ms = 6;

  // Niche feature: If true this will resolve file descriptors for each process
  // so these can be mapped to their actual device or file.
  // Requires raw_syscalls/sys_{enter,exit} ftrace events to be enabled or
  // new fds opened after initially scanning a process will not be
  // recognized.
  optional bool resolve_process_fds = 9;

  // If true, output will include memory stats from /proc/pid/smaps_rollup.
  optional bool scan_smaps_rollup = 10;

  // If true: process descriptions will include process age (starttime in
  // /proc/pid/stat).
  // Introduced in: dejaview v44.
  optional bool record_process_age = 11;

  // If true and |proc_stats_poll_ms| is true, process stats will include time
  // spent running in user/kernel mode (utime/stime in /proc/pid/stat).
  // Introduced in: dejaview v44.
  optional bool record_process_runtime = 12;

  // record_thread_time_in_state
  reserved 7;
  // thread_time_in_state_cache_size
  reserved 8;
}

// End of protos/dejaview/config/process_stats/process_stats_config.proto

// Begin of protos/dejaview/common/sys_stats_counters.proto

// When editing entries here remember also to update "sys_stats_counters.h" with
// the corresponding string definitions for the actual /proc files parser.

// Counter definitions for Linux's /proc/meminfo.
enum MeminfoCounters {
  MEMINFO_UNSPECIFIED = 0;
  MEMINFO_MEM_TOTAL = 1;
  MEMINFO_MEM_FREE = 2;
  MEMINFO_MEM_AVAILABLE = 3;
  MEMINFO_BUFFERS = 4;
  MEMINFO_CACHED = 5;
  MEMINFO_SWAP_CACHED = 6;
  MEMINFO_ACTIVE = 7;
  MEMINFO_INACTIVE = 8;
  MEMINFO_ACTIVE_ANON = 9;
  MEMINFO_INACTIVE_ANON = 10;
  MEMINFO_ACTIVE_FILE = 11;
  MEMINFO_INACTIVE_FILE = 12;
  MEMINFO_UNEVICTABLE = 13;
  MEMINFO_MLOCKED = 14;
  MEMINFO_SWAP_TOTAL = 15;
  MEMINFO_SWAP_FREE = 16;
  MEMINFO_DIRTY = 17;
  MEMINFO_WRITEBACK = 18;
  MEMINFO_ANON_PAGES = 19;
  MEMINFO_MAPPED = 20;
  MEMINFO_SHMEM = 21;
  MEMINFO_SLAB = 22;
  MEMINFO_SLAB_RECLAIMABLE = 23;
  MEMINFO_SLAB_UNRECLAIMABLE = 24;
  MEMINFO_KERNEL_STACK = 25;
  MEMINFO_PAGE_TABLES = 26;
  MEMINFO_COMMIT_LIMIT = 27;
  MEMINFO_COMMITED_AS = 28;
  MEMINFO_VMALLOC_TOTAL = 29;
  MEMINFO_VMALLOC_USED = 30;
  MEMINFO_VMALLOC_CHUNK = 31;
  MEMINFO_CMA_TOTAL = 32;
  MEMINFO_CMA_FREE = 33;
  MEMINFO_GPU = 34;
  MEMINFO_ZRAM = 35;
  MEMINFO_MISC = 36;
  MEMINFO_ION_HEAP = 37;
  MEMINFO_ION_HEAP_POOL = 38;
}

// Counter definitions for Linux's /proc/vmstat.
enum VmstatCounters {
  VMSTAT_UNSPECIFIED = 0;
  VMSTAT_NR_FREE_PAGES = 1;
  VMSTAT_NR_ALLOC_BATCH = 2;
  VMSTAT_NR_INACTIVE_ANON = 3;
  VMSTAT_NR_ACTIVE_ANON = 4;
  VMSTAT_NR_INACTIVE_FILE = 5;
  VMSTAT_NR_ACTIVE_FILE = 6;
  VMSTAT_NR_UNEVICTABLE = 7;
  VMSTAT_NR_MLOCK = 8;
  VMSTAT_NR_ANON_PAGES = 9;
  VMSTAT_NR_MAPPED = 10;
  VMSTAT_NR_FILE_PAGES = 11;
  VMSTAT_NR_DIRTY = 12;
  VMSTAT_NR_WRITEBACK = 13;
  VMSTAT_NR_SLAB_RECLAIMABLE = 14;
  VMSTAT_NR_SLAB_UNRECLAIMABLE = 15;
  VMSTAT_NR_PAGE_TABLE_PAGES = 16;
  VMSTAT_NR_KERNEL_STACK = 17;
  VMSTAT_NR_OVERHEAD = 18;
  VMSTAT_NR_UNSTABLE = 19;
  VMSTAT_NR_BOUNCE = 20;
  VMSTAT_NR_VMSCAN_WRITE = 21;
  VMSTAT_NR_VMSCAN_IMMEDIATE_RECLAIM = 22;
  VMSTAT_NR_WRITEBACK_TEMP = 23;
  VMSTAT_NR_ISOLATED_ANON = 24;
  VMSTAT_NR_ISOLATED_FILE = 25;
  VMSTAT_NR_SHMEM = 26;
  VMSTAT_NR_DIRTIED = 27;
  VMSTAT_NR_WRITTEN = 28;
  VMSTAT_NR_PAGES_SCANNED = 29;
  VMSTAT_WORKINGSET_REFAULT = 30;
  VMSTAT_WORKINGSET_ACTIVATE = 31;
  VMSTAT_WORKINGSET_NODERECLAIM = 32;
  VMSTAT_NR_ANON_TRANSPARENT_HUGEPAGES = 33;
  VMSTAT_NR_FREE_CMA = 34;
  VMSTAT_NR_SWAPCACHE = 35;
  VMSTAT_NR_DIRTY_THRESHOLD = 36;
  VMSTAT_NR_DIRTY_BACKGROUND_THRESHOLD = 37;
  VMSTAT_PGPGIN = 38;
  VMSTAT_PGPGOUT = 39;
  VMSTAT_PGPGOUTCLEAN = 40;
  VMSTAT_PSWPIN = 41;
  VMSTAT_PSWPOUT = 42;
  VMSTAT_PGALLOC_DMA = 43;
  VMSTAT_PGALLOC_NORMAL = 44;
  VMSTAT_PGALLOC_MOVABLE = 45;
  VMSTAT_PGFREE = 46;
  VMSTAT_PGACTIVATE = 47;
  VMSTAT_PGDEACTIVATE = 48;
  VMSTAT_PGFAULT = 49;
  VMSTAT_PGMAJFAULT = 50;
  VMSTAT_PGREFILL_DMA = 51;
  VMSTAT_PGREFILL_NORMAL = 52;
  VMSTAT_PGREFILL_MOVABLE = 53;
  VMSTAT_PGSTEAL_KSWAPD_DMA = 54;
  VMSTAT_PGSTEAL_KSWAPD_NORMAL = 55;
  VMSTAT_PGSTEAL_KSWAPD_MOVABLE = 56;
  VMSTAT_PGSTEAL_DIRECT_DMA = 57;
  VMSTAT_PGSTEAL_DIRECT_NORMAL = 58;
  VMSTAT_PGSTEAL_DIRECT_MOVABLE = 59;
  VMSTAT_PGSCAN_KSWAPD_DMA = 60;
  VMSTAT_PGSCAN_KSWAPD_NORMAL = 61;
  VMSTAT_PGSCAN_KSWAPD_MOVABLE = 62;
  VMSTAT_PGSCAN_DIRECT_DMA = 63;
  VMSTAT_PGSCAN_DIRECT_NORMAL = 64;
  VMSTAT_PGSCAN_DIRECT_MOVABLE = 65;
  VMSTAT_PGSCAN_DIRECT_THROTTLE = 66;
  VMSTAT_PGINODESTEAL = 67;
  VMSTAT_SLABS_SCANNED = 68;
  VMSTAT_KSWAPD_INODESTEAL = 69;
  VMSTAT_KSWAPD_LOW_WMARK_HIT_QUICKLY = 70;
  VMSTAT_KSWAPD_HIGH_WMARK_HIT_QUICKLY = 71;
  VMSTAT_PAGEOUTRUN = 72;
  VMSTAT_ALLOCSTALL = 73;
  VMSTAT_PGROTATED = 74;
  VMSTAT_DROP_PAGECACHE = 75;
  VMSTAT_DROP_SLAB = 76;
  VMSTAT_PGMIGRATE_SUCCESS = 77;
  VMSTAT_PGMIGRATE_FAIL = 78;
  VMSTAT_COMPACT_MIGRATE_SCANNED = 79;
  VMSTAT_COMPACT_FREE_SCANNED = 80;
  VMSTAT_COMPACT_ISOLATED = 81;
  VMSTAT_COMPACT_STALL = 82;
  VMSTAT_COMPACT_FAIL = 83;
  VMSTAT_COMPACT_SUCCESS = 84;
  VMSTAT_COMPACT_DAEMON_WAKE = 85;
  VMSTAT_UNEVICTABLE_PGS_CULLED = 86;
  VMSTAT_UNEVICTABLE_PGS_SCANNED = 87;
  VMSTAT_UNEVICTABLE_PGS_RESCUED = 88;
  VMSTAT_UNEVICTABLE_PGS_MLOCKED = 89;
  VMSTAT_UNEVICTABLE_PGS_MUNLOCKED = 90;
  VMSTAT_UNEVICTABLE_PGS_CLEARED = 91;
  VMSTAT_UNEVICTABLE_PGS_STRANDED = 92;
  VMSTAT_NR_ZSPAGES = 93;
  VMSTAT_NR_ION_HEAP = 94;
  VMSTAT_NR_GPU_HEAP = 95;
  VMSTAT_ALLOCSTALL_DMA = 96;
  VMSTAT_ALLOCSTALL_MOVABLE = 97;
  VMSTAT_ALLOCSTALL_NORMAL = 98;
  VMSTAT_COMPACT_DAEMON_FREE_SCANNED = 99;
  VMSTAT_COMPACT_DAEMON_MIGRATE_SCANNED = 100;
  VMSTAT_NR_FASTRPC = 101;
  VMSTAT_NR_INDIRECTLY_RECLAIMABLE = 102;
  VMSTAT_NR_ION_HEAP_POOL = 103;
  VMSTAT_NR_KERNEL_MISC_RECLAIMABLE = 104;
  VMSTAT_NR_SHADOW_CALL_STACK_BYTES = 105;
  VMSTAT_NR_SHMEM_HUGEPAGES = 106;
  VMSTAT_NR_SHMEM_PMDMAPPED = 107;
  VMSTAT_NR_UNRECLAIMABLE_PAGES = 108;
  VMSTAT_NR_ZONE_ACTIVE_ANON = 109;
  VMSTAT_NR_ZONE_ACTIVE_FILE = 110;
  VMSTAT_NR_ZONE_INACTIVE_ANON = 111;
  VMSTAT_NR_ZONE_INACTIVE_FILE = 112;
  VMSTAT_NR_ZONE_UNEVICTABLE = 113;
  VMSTAT_NR_ZONE_WRITE_PENDING = 114;
  VMSTAT_OOM_KILL = 115;
  VMSTAT_PGLAZYFREE = 116;
  VMSTAT_PGLAZYFREED = 117;
  VMSTAT_PGREFILL = 118;
  VMSTAT_PGSCAN_DIRECT = 119;
  VMSTAT_PGSCAN_KSWAPD = 120;
  VMSTAT_PGSKIP_DMA = 121;
  VMSTAT_PGSKIP_MOVABLE = 122;
  VMSTAT_PGSKIP_NORMAL = 123;
  VMSTAT_PGSTEAL_DIRECT = 124;
  VMSTAT_PGSTEAL_KSWAPD = 125;
  VMSTAT_SWAP_RA = 126;
  VMSTAT_SWAP_RA_HIT = 127;
  VMSTAT_WORKINGSET_RESTORE = 128;
  VMSTAT_ALLOCSTALL_DEVICE = 129;
  VMSTAT_ALLOCSTALL_DMA32 = 130;
  VMSTAT_BALLOON_DEFLATE = 131;
  VMSTAT_BALLOON_INFLATE = 132;
  VMSTAT_BALLOON_MIGRATE = 133;
  VMSTAT_CMA_ALLOC_FAIL = 134;
  VMSTAT_CMA_ALLOC_SUCCESS = 135;
  VMSTAT_NR_FILE_HUGEPAGES = 136;
  VMSTAT_NR_FILE_PMDMAPPED = 137;
  VMSTAT_NR_FOLL_PIN_ACQUIRED = 138;
  VMSTAT_NR_FOLL_PIN_RELEASED = 139;
  VMSTAT_NR_SEC_PAGE_TABLE_PAGES = 140;
  VMSTAT_NR_SHADOW_CALL_STACK = 141;
  VMSTAT_NR_SWAPCACHED = 142;
  VMSTAT_NR_THROTTLED_WRITTEN = 143;
  VMSTAT_PGALLOC_DEVICE = 144;
  VMSTAT_PGALLOC_DMA32 = 145;
  VMSTAT_PGDEMOTE_DIRECT = 146;
  VMSTAT_PGDEMOTE_KSWAPD = 147;
  VMSTAT_PGREUSE = 148;
  VMSTAT_PGSCAN_ANON = 149;
  VMSTAT_PGSCAN_FILE = 150;
  VMSTAT_PGSKIP_DEVICE = 151;
  VMSTAT_PGSKIP_DMA32 = 152;
  VMSTAT_PGSTEAL_ANON = 153;
  VMSTAT_PGSTEAL_FILE = 154;
  VMSTAT_THP_COLLAPSE_ALLOC = 155;
  VMSTAT_THP_COLLAPSE_ALLOC_FAILED = 156;
  VMSTAT_THP_DEFERRED_SPLIT_PAGE = 157;
  VMSTAT_THP_FAULT_ALLOC = 158;
  VMSTAT_THP_FAULT_FALLBACK = 159;
  VMSTAT_THP_FAULT_FALLBACK_CHARGE = 160;
  VMSTAT_THP_FILE_ALLOC = 161;
  VMSTAT_THP_FILE_FALLBACK = 162;
  VMSTAT_THP_FILE_FALLBACK_CHARGE = 163;
  VMSTAT_THP_FILE_MAPPED = 164;
  VMSTAT_THP_MIGRATION_FAIL = 165;
  VMSTAT_THP_MIGRATION_SPLIT = 166;
  VMSTAT_THP_MIGRATION_SUCCESS = 167;
  VMSTAT_THP_SCAN_EXCEED_NONE_PTE = 168;
  VMSTAT_THP_SCAN_EXCEED_SHARE_PTE = 169;
  VMSTAT_THP_SCAN_EXCEED_SWAP_PTE = 170;
  VMSTAT_THP_SPLIT_PAGE = 171;
  VMSTAT_THP_SPLIT_PAGE_FAILED = 172;
  VMSTAT_THP_SPLIT_PMD = 173;
  VMSTAT_THP_SWPOUT = 174;
  VMSTAT_THP_SWPOUT_FALLBACK = 175;
  VMSTAT_THP_ZERO_PAGE_ALLOC = 176;
  VMSTAT_THP_ZERO_PAGE_ALLOC_FAILED = 177;
  VMSTAT_VMA_LOCK_ABORT = 178;
  VMSTAT_VMA_LOCK_MISS = 179;
  VMSTAT_VMA_LOCK_RETRY = 180;
  VMSTAT_VMA_LOCK_SUCCESS = 181;
  VMSTAT_WORKINGSET_ACTIVATE_ANON = 182;
  VMSTAT_WORKINGSET_ACTIVATE_FILE = 183;
  VMSTAT_WORKINGSET_NODES = 184;
  VMSTAT_WORKINGSET_REFAULT_ANON = 185;
  VMSTAT_WORKINGSET_REFAULT_FILE = 186;
  VMSTAT_WORKINGSET_RESTORE_ANON = 187;
  VMSTAT_WORKINGSET_RESTORE_FILE = 188;
}

// End of protos/dejaview/common/sys_stats_counters.proto

// Begin of protos/dejaview/config/sys_stats/sys_stats_config.proto

// This file defines the configuration for the Linux /proc poller data source,
// which injects counters in the trace.
// Counters that are needed in the trace must be explicitly listed in the
// *_counters fields. This is to avoid spamming the trace with all counters
// at all times.
// The sampling rate is configurable. All polling rates (*_period_ms) need
// to be integer multiples of each other.
// OK:     [10ms, 10ms, 10ms],  [10ms, 20ms, 10ms],  [10ms, 20ms, 60ms]
// Not OK: [10ms, 10ms, 11ms],  [10ms, 15ms, 20ms]
message SysStatsConfig {
  // Polls /proc/meminfo every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  // Cost: 0.3 ms [read] + 0.07 ms [parse + trace injection]
  optional uint32 meminfo_period_ms = 1;

  // If empty all known counters are reported. Otherwise, only the counters
  // specified below are reported.
  repeated MeminfoCounters meminfo_counters = 2;

  // Polls /proc/vmstat every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  // Cost: 0.2 ms [read] + 0.3 ms [parse + trace injection]
  optional uint32 vmstat_period_ms = 3;
  repeated VmstatCounters vmstat_counters = 4;

  // Pols /proc/stat every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  // Cost: 4.1 ms [read] + 1.9 ms [parse + trace injection]
  optional uint32 stat_period_ms = 5;
  enum StatCounters {
    STAT_UNSPECIFIED = 0;
    STAT_CPU_TIMES = 1;
    STAT_IRQ_COUNTS = 2;
    STAT_SOFTIRQ_COUNTS = 3;
    STAT_FORK_COUNT = 4;
  }
  repeated StatCounters stat_counters = 6;

  // Polls /sys/devfreq/*/curfreq every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  // This option can be used to record unchanging values.
  // Updates from frequency changes can come from ftrace/set_clock_rate.
  optional uint32 devfreq_period_ms = 7;

  // Polls /sys/devices/system/cpu/cpu*/cpufreq/cpuinfo_cur_freq every X ms.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 cpufreq_period_ms = 8;

  // Polls /proc/buddyinfo every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 buddyinfo_period_ms = 9;

  // Polls /proc/diskstats every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 diskstat_period_ms = 10;

  // Polls /proc/pressure/* every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 psi_period_ms = 11;

  // Polls /sys/class/thermal/* every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 thermal_period_ms = 12;

  // Polls /sys/devices/system/cpu/cpu*/cpuidle/state* every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 cpuidle_period_ms = 13;

  // Polls device-specific GPU frequency info every X ms, if non-zero.
  // This is required to be > 10ms to avoid excessive CPU usage.
  optional uint32 gpufreq_period_ms = 14;
}

// End of protos/dejaview/config/sys_stats/sys_stats_config.proto

// Begin of protos/dejaview/config/system_info/system_info.proto

// This data-source does a one-off recording of system information when
// the trace starts.
// Currently this includes:
// - Values of
// /sys/devices/system/cpu/cpu*/cpufreq/scaling_available_frequencies This
// datasource has no configuration options at present.
message SystemInfoConfig {}

// End of protos/dejaview/config/system_info/system_info.proto

// Begin of protos/dejaview/config/test_config.proto

// The configuration for a fake producer used in tests.
message TestConfig {
  message DummyFields {
    optional uint32 field_uint32 = 1;
    optional int32 field_int32 = 2;
    optional uint64 field_uint64 = 3;
    optional int64 field_int64 = 4;
    optional fixed64 field_fixed64 = 5;
    optional sfixed64 field_sfixed64 = 6;
    optional fixed32 field_fixed32 = 7;
    optional sfixed32 field_sfixed32 = 8;
    optional double field_double = 9;
    optional float field_float = 10;
    optional sint64 field_sint64 = 11;
    optional sint32 field_sint32 = 12;
    optional string field_string = 13;
    optional bytes field_bytes = 14;
  }

  // The number of messages the fake producer should send.
  optional uint32 message_count = 1;

  // The maximum number of messages which should be sent each second.
  // The actual obserced speed may be lower if the producer is unable to
  // work fast enough.
  // If this is zero or unset, the producer will send as fast as possible.
  optional uint32 max_messages_per_second = 2;

  // The seed value for a simple multiplicative congruential pseudo-random
  // number sequence.
  optional uint32 seed = 3;

  // The size of each message in bytes. Should be greater than or equal 5 to
  // account for the number of bytes needed to encode the random number and a
  // null byte for the string.
  optional uint32 message_size = 4;

  // Whether the producer should send a event batch when the data source is
  // is initially registered.
  optional bool send_batch_on_register = 5;

  optional DummyFields dummy_fields = 6;
}

// End of protos/dejaview/config/test_config.proto

// Begin of protos/dejaview/config/track_event/track_event_config.proto

message TrackEventConfig {
  // The following fields define the set of enabled trace categories. Each list
  // item is a glob.
  //
  // To determine if category is enabled, it is checked against the filters in
  // the following order:
  //
  //   1. Exact matches in enabled categories.
  //   2. Exact matches in enabled tags.
  //   3. Exact matches in disabled categories.
  //   4. Exact matches in disabled tags.
  //   5. Pattern matches in enabled categories.
  //   6. Pattern matches in enabled tags.
  //   7. Pattern matches in disabled categories.
  //   8. Pattern matches in disabled tags.
  //
  // If none of the steps produced a match:
  //  - In the C++ SDK (`dejaview::Category`), categories are enabled by
  //  default.
  //  - In the C SDK (`DejaViewTeCategory`), categories are disabled by default.
  //
  // Examples:
  //
  //  - To enable all non-slow/debug categories:
  //
  //       enabled_categories: "*"
  //
  //  - To enable specific categories:
  //
  //       disabled_categories: "*"
  //       enabled_categories: "my_category"
  //       enabled_categories: "my_category2"
  //
  //  - To enable only categories with a specific tag:
  //
  //       disabled_tags: "*"
  //       enabled_tags: "my_tag"
  //

  // Default: []
  repeated string disabled_categories = 1;

  // Default: []
  repeated string enabled_categories = 2;

  // Default: ["slow", "debug"]
  repeated string disabled_tags = 3;

  // Default: []
  repeated string enabled_tags = 4;

  // Default: false (i.e. enabled by default)
  optional bool disable_incremental_timestamps = 5;

  // Allows to specify a custom unit different than the default (ns).
  // Also affects thread timestamps if enable_thread_time_sampling = true.
  // A multiplier of 1000 means that a timestamp = 3 should be interpreted as
  // 3000 ns = 3 us.
  // Default: 1 (if unset, it should be read as 1).
  optional uint64 timestamp_unit_multiplier = 6;

  // Default: false (i.e. debug_annotations is NOT filtered out by default)
  // When true, any debug annotations provided as arguments to the
  // TRACE_EVENT macros are not written into the trace. Typed arguments will
  // still be emitted even if set to true.
  optional bool filter_debug_annotations = 7;

  // Default : false (i.e. disabled)
  // When true, the SDK samples and emits the current thread time counter value
  // for each event on the current thread's track. This value represents the
  // total CPU time consumed by that thread since its creation. Note that if a
  // thread is not scheduled by OS for some duration, that time won't be
  // included in thread_time.
  // Learn more : "CLOCK_THREAD_CPUTIME_ID" flag at
  // https://linux.die.net/man/3/clock_gettime
  optional bool enable_thread_time_sampling = 8;

  // Default: false (i.e. dynamic event names are NOT filtered out by default)
  // When true, event_names wrapped in dejaview::DynamicString will be filtered
  // out.
  optional bool filter_dynamic_event_names = 9;
}

// End of protos/dejaview/config/track_event/track_event_config.proto

// Begin of protos/dejaview/config/data_source_config.proto

// The configuration that is passed to each data source when starting tracing.
// Next id: 131
message DataSourceConfig {
  enum SessionInitiator {
    SESSION_INITIATOR_UNSPECIFIED = 0;
    // This trace was initiated from a trusted system app has DUMP and
    // USAGE_STATS permission. This system app is expected to not expose the
    // trace to the user of the device.
    // This is determined by checking the UID initiating the trace.
    SESSION_INITIATOR_TRUSTED_SYSTEM = 1;
  };
  // Data source unique name, e.g., "linux.ftrace". This must match
  // the name passed by the data source when it registers (see
  // RegisterDataSource()).
  optional string name = 1;

  // The index of the logging buffer where TracePacket(s) will be stored.
  // This field doesn't make a major difference for the Producer(s). The final
  // logging buffers, in fact, are completely owned by the Service. We just ask
  // the Producer to copy this number into the chunk headers it emits, so that
  // the Service can quickly identify the buffer where to move the chunks into
  // without expensive lookups on its fastpath.
  optional uint32 target_buffer = 2;

  // Set by the service to indicate the duration of the trace.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional uint32 trace_duration_ms = 3;

  // If true, |trace_duration_ms| should count also time in suspend. This
  // is propagated from TraceConfig.prefer_suspend_clock_for_duration.
  optional bool prefer_suspend_clock_for_duration = 122;

  // Set by the service to indicate how long it waits after StopDataSource.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional uint32 stop_timeout_ms = 7;

  // Set by the service to indicate whether this tracing session has extra
  // guardrails.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional bool enable_extra_guardrails = 6;

  // Set by the service to indicate which user initiated this trace.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional SessionInitiator session_initiator = 8;

  // Set by the service to indicate which tracing session the data source
  // belongs to. The intended use case for this is checking if two data sources,
  // one of which produces metadata for the other one, belong to the same trace
  // session and hence should be linked together.
  // This field was introduced in Aug 2018 after Android P.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional uint64 tracing_session_id = 4;

  // Keeep the lower IDs (up to 99) for fields that are *not* specific to
  // data-sources and needs to be processed by the traced daemon.

  // All data source config fields must be marked as [lazy=true]. This prevents
  // the proto-to-cpp generator from recursing into those when generating the
  // cpp classes and polluting tracing/core with data-source-specific classes.
  // Instead they are treated as opaque strings containing raw proto bytes.

  // Data source name: linux.inode_file_map
  optional InodeFileConfig inode_file_config = 102 [lazy = true];
  // Data source name: linux.process_stats
  optional ProcessStatsConfig process_stats_config = 103 [lazy = true];
  // Data source name: linux.sys_stats
  optional SysStatsConfig sys_stats_config = 104 [lazy = true];
  // Data source name: track_event
  optional TrackEventConfig track_event_config = 113 [lazy = true];
  // Data source name: linux.system_info
  optional SystemInfoConfig system_info_config = 119;

  // If an interceptor is specified here, packets for this data source will be
  // rerouted to the interceptor instead of the main trace buffer. This can be
  // used, for example, to write trace data into ETW or for logging trace points
  // to the console.
  //
  // Note that interceptors are only supported by data sources registered
  // through the DejaView SDK API. Data sources that don't use that API (e.g.,
  // traced_probes) may not support interception.
  optional InterceptorConfig interceptor_config = 115;

  // This is a fallback mechanism to send a free-form text config to the
  // producer. In theory this should never be needed. All the code that
  // is part of the platform (i.e. traced service) is supposed to *not* truncate
  // the trace config proto and propagate unknown fields. However, if anything
  // in the pipeline (client or backend) ends up breaking this forward compat
  // plan, this field will become the escape hatch to allow future data sources
  // to get some meaningful configuration.
  optional string legacy_config = 1000;

  // This field is only used for testing.
  optional TestConfig for_testing = 1001;

  // Was |for_testing|. Caused more problems then found.
  reserved 268435455;
}

// End of protos/dejaview/config/data_source_config.proto

// Begin of protos/dejaview/config/trace_config.proto

// The overall config that is used when starting a new tracing session through
// ProducerPort::StartTracing().
// It contains the general config for the logging buffer(s) and the configs for
// all the data source being enabled.
//
// Next id: 40.
message TraceConfig {
  message BufferConfig {
    optional uint32 size_kb = 1;

    // |page_size|, now deprecated.
    reserved 2;

    // |optimize_for|, now deprecated.
    reserved 3;

    enum FillPolicy {
      UNSPECIFIED = 0;

      // Default behavior. The buffer operates as a conventional ring buffer.
      // If the writer is faster than the reader (or if the reader reads only
      // after tracing is stopped) newly written packets will overwrite old
      // packets.
      RING_BUFFER = 1;

      // Behaves like RING_BUFFER as long as there is space in the buffer or
      // the reader catches up with the writer. As soon as the writer hits
      // an unread chunk, it stops accepting new data in the buffer.
      DISCARD = 2;
    }
    optional FillPolicy fill_policy = 4;

    // When true the buffer is moved (rather than copied) onto the cloned
    // session, and an empty buffer of the same size is allocated in the source
    // tracing session. This feature will likely get deprecated in the future.
    // It been introduced mainly to support the surfaceflinger snapshot dump
    // for bugreports, where SF can dumps O(400MB) into the bugreport trace. In
    // that case we don't want to retain another in-memory copy of the buffer.
    optional bool transfer_on_clone = 5;

    // Used in conjuction with transfer_on_clone. When true the buffer is
    // cleared before issuing the Flush(reason=kTraceClone). This is to ensure
    // that if the data source took too long to write the data in a previous
    // clone-related flush, we don't end up with a mixture of leftovers from
    // the previous write and new data.
    optional bool clear_before_clone = 6;
  }
  repeated BufferConfig buffers = 1;

  message DataSource {
    // Filters and data-source specific config. It contains also the unique name
    // of the data source, the one passed in the  DataSourceDescriptor when they
    // register on the service.
    optional protos.DataSourceConfig config = 1;

    // Optional. If multiple producers (~processes) expose the same data source
    // and either |producer_name_filter| or |producer_name_regex_filter| is set,
    // the data source is enabled only for producers whose names match any of
    // the filters.
    // |producer_name_filter| has to be an exact match, while
    // |producer_name_regex_filter| is a regular expression.
    // This allows to enable a data source only for specific processes.
    // The "repeated" fields have OR semantics: specifying a filter ["foo",
    // "bar"] will enable data sources on both "foo" and "bar" (if they exist).
    repeated string producer_name_filter = 2;
    repeated string producer_name_regex_filter = 3;
  }
  repeated DataSource data_sources = 2;

  // Config for disabling builtin data sources in the tracing service.
  message BuiltinDataSource {
    // Disable emitting clock timestamps into the trace.
    optional bool disable_clock_snapshotting = 1;

    // Disable echoing the original trace config in the trace.
    optional bool disable_trace_config = 2;

    // Disable emitting system info (build fingerprint, cpuinfo, etc).
    optional bool disable_system_info = 3;

    // Disable emitting events for data-source state changes (e.g. the marker
    // for all data sources having ACKed the start of the trace).
    optional bool disable_service_events = 4;

    // The authoritative clock domain for the trace. Defaults to BOOTTIME. See
    // also ClockSnapshot's primary_trace_clock. The configured value is written
    // into the trace as part of the ClockSnapshots emitted by the service.
    // Trace processor will attempt to translate packet/event timestamps from
    // various data sources (and their chosen clock domains) to this domain
    // during import. Added in Android R.
    optional BuiltinClock primary_trace_clock = 5;

    // Time interval in between snapshotting of sync markers, clock snapshots,
    // stats, and other periodic service-emitted events. Note that the service
    // only keeps track of the first and the most recent snapshot until
    // ReadBuffers() is called.
    optional uint32 snapshot_interval_ms = 6;

    // Hints to the service that a suspend-aware (i.e. counting time in suspend)
    // clock should be used for periodic snapshots of service-emitted events.
    // This means, if a snapshot *should* have happened during suspend, it will
    // happen immediately after the device resumes.
    //
    // Choosing a clock like this is done on best-effort basis; not all
    // platforms (e.g. Windows) expose a clock which can be used for periodic
    // tasks counting suspend. If such a clock is not available, the service
    // falls back to the best-available alternative.
    //
    // Introduced in Android S.
    // TODO(lalitm): deprecate this in T and make this the default if nothing
    // crashes in S.
    optional bool prefer_suspend_clock_for_snapshot = 7;

    // Disables the reporting of per-trace-writer histograms in TraceStats.
    optional bool disable_chunk_usage_histograms = 8;
  }
  optional BuiltinDataSource builtin_data_sources = 20;

  // If specified, the trace will be stopped |duration_ms| after starting.
  // This does *not* count the time the system is suspended, so we will run
  // for duration_ms of system activity, not wall time.
  //
  // However in case of traces with triggers, see
  // TriggerConfig.trigger_timeout_ms instead.
  optional uint32 duration_ms = 3;

  // If true, tries to use CLOCK_BOOTTIME for duration_ms rather than
  // CLOCK_MONOTONIC (which doesn't count time in suspend). Supported only on
  // Linux/Android, no-op on other platforms. This is used when dealing with
  // long (e.g. 24h) traces, where suspend can inflate them to weeks of
  // wall-time, making them more likely to hit device reboots (and hence loss).
  // This option also changes consistently the semantic of
  // TriggerConfig.stop_delay_ms.
  optional bool prefer_suspend_clock_for_duration = 36;

  // This is set when --dropbox is passed to the DejaView command line client
  // and enables guardrails that limit resource usage for traces requested
  // by statsd.
  optional bool enable_extra_guardrails = 4;

  enum LockdownModeOperation {
    LOCKDOWN_UNCHANGED = 0;
    LOCKDOWN_CLEAR = 1;
    LOCKDOWN_SET = 2;
  }
  // Reject producers that are not running under the same UID as the tracing
  // service.
  optional LockdownModeOperation lockdown_mode = 5;

  message ProducerConfig {
    // Identifies the producer for which this config is for.
    optional string producer_name = 1;

    // Specifies the preferred size of the shared memory buffer. If the size is
    // larger than the max size, the max will be used. If it is smaller than
    // the page size or doesn't fit pages evenly into it, it will fall back to
    // the size specified by the producer or finally the default shared memory
    // size.
    optional uint32 shm_size_kb = 2;

    // Specifies the preferred size of each page in the shared memory buffer.
    // Must be an integer multiple of 4K.
    optional uint32 page_size_kb = 3;
  }

  repeated ProducerConfig producers = 6;

  // Contains statsd-specific metadata about an alert associated with the trace.
  message StatsdMetadata {
    // The identifier of the alert which triggered this trace.
    optional int64 triggering_alert_id = 1;
    // The uid which registered the triggering configuration with statsd.
    optional int32 triggering_config_uid = 2;
    // The identifier of the config which triggered the alert.
    optional int64 triggering_config_id = 3;
    // The identifier of the subscription which triggered this trace.
    optional int64 triggering_subscription_id = 4;
  }

  // Statsd-specific metadata.
  optional StatsdMetadata statsd_metadata = 7;

  // When true && |output_path| is empty, the EnableTracing() request must
  // provide a file descriptor. The service will then periodically read packets
  // out of the trace buffer and store it into the passed file.
  // If |output_path| is not empty no fd should be passed, the service
  // will create a new file and write into that (see comment below).
  optional bool write_into_file = 8;

  // This must point to a non-existing file. If the file exists the service
  // will NOT overwrite and will fail instead as a security precaution.
  // On Android, when this is used with the system traced, the path must be
  // within /data/misc/dejaview-traces/ or the trace will fail.
  // This option has been introduced in Android R. Before R write_into_file
  // can be used only with the "pass a file descriptor over IPC" mode.
  optional string output_path = 29;

  // Optional. If non-zero tunes the write period. A min value of 100ms is
  // enforced (i.e. smaller values are ignored).
  optional uint32 file_write_period_ms = 9;

  // Optional. When non zero the periodic write stops once at most X bytes
  // have been written into the file. Tracing is disabled when this limit is
  // reached, even if |duration_ms| has not been reached yet.
  optional uint64 max_file_size_bytes = 10;

  // Contains flags which override the default values of the guardrails inside
  // DejaView.
  message GuardrailOverrides {
    // Override the default limit (in bytes) for uploading data to server within
    // a 24 hour period.
    // On R-, this override only affected userdebug builds. Since S, it also
    // affects user builds.
    // In 24Q3+ (V+), this override is a noop because upload guardrail logic
    // was removed from DejaView.
    optional uint64 max_upload_per_day_bytes = 1 [deprecated = true];

    // Overrides the guardrail for maximum trace buffer size.
    // Available on U+
    optional uint32 max_tracing_buffer_size_kb = 2;
  }
  optional GuardrailOverrides guardrail_overrides = 11;

  // When true, data sources are not started until an explicit call to
  // StartTracing() on the consumer port. This is to support early
  // initialization and fast trace triggering. This can be used only when the
  // Consumer explicitly triggers the StartTracing() method.
  // This should not be used in a remote trace config via statsd, doing so will
  // result in a hung trace session.
  optional bool deferred_start = 12;

  // When set, it periodically issues a Flush() to all data source, forcing them
  // to commit their data into the tracing service. This can be used for
  // quasi-real-time streaming mode and to guarantee some partial ordering of
  // events in the trace in windows of X ms.
  optional uint32 flush_period_ms = 13;

  // Wait for this long for producers to acknowledge flush requests.
  // Default 5s.
  optional uint32 flush_timeout_ms = 14;

  // Wait for this long for producers to acknowledge stop requests.
  // Default 5s.
  optional uint32 data_source_stop_timeout_ms = 23;

  // |disable_clock_snapshotting| moved.
  reserved 15;

  // Android-only. If set, sends an intent to the Traceur system app when the
  // trace ends to notify it about the trace readiness.
  optional bool notify_traceur = 16;

  // This field was introduced in Android S.
  // Android-only. If set to a value > 0, marks the trace session as a candidate
  // for being attached to a bugreport. This field effectively acts as a z-index
  // for bugreports. When Android's dumpstate runs dejaview
  // --save-for-bugreport, traced will pick the tracing session with the highest
  // score (score <= 0 is ignored) and:
  // On Android S, T:  will steal its contents, save the trace into
  //     a known path and stop prematurely.
  // On Android U+: will create a read-only snapshot and save that into a known
  //     path, without stoppin the original tracing session.
  // When this field is set the tracing session becomes eligible to be cloned
  // by other UIDs.
  optional int32 bugreport_score = 30;

  // When set, defines name of the file that will be saved under
  // /data/misc/dejaview-traces/bugreport/ when using --save-all-for-bugreport.
  // If omitted, traces will be named systrace.pftrace, systrace_1.pftrace, etc,
  // starting from the highest `bugreport_score`.
  // Introduced in v42 / Android V.
  optional string bugreport_filename = 38;

  // Triggers allow producers to start or stop the tracing session when an event
  // occurs.
  //
  // For example if we are tracing probabilistically, most traces will be
  // uninteresting. Triggers allow us to keep only the interesting ones such as
  // those traces during which the device temperature reached a certain
  // threshold. In this case the producer can activate a trigger to keep
  // (STOP_TRACING) the trace, otherwise it can also begin a trace
  // (START_TRACING) because it knows something is about to happen.
  message TriggerConfig {
    enum TriggerMode {
      UNSPECIFIED = 0;

      // When this mode is chosen, data sources are not started until one of the
      // |triggers| are received. This supports early initialization and fast
      // starting of the tracing system. On triggering, the session will then
      // record for |stop_delay_ms|. However if no trigger is seen
      // after |trigger_timeout_ms| the session will be stopped and no data will
      // be returned.
      START_TRACING = 1;

      // When this mode is chosen, the session will be started via the normal
      // EnableTracing() & StartTracing(). If no trigger is ever seen
      // the session will be stopped after |trigger_timeout_ms| and no data will
      // be returned. However if triggered the trace will stop after
      // |stop_delay_ms| and any data in the buffer will be returned to the
      // consumer.
      STOP_TRACING = 2;

      // 3 was taken by CLONE_SNAPSHOT but that has been moved to 4.
      // The early implementation of CLONE_SNAPSHOT had various bugs
      // (b/290798988, b/290799105) and made it into Android U. The number
      // change is to make sure nobody rolls out a config that hits the broken
      // behaviour.
      reserved 3;

      // When this mode is chosen, this causes a snapshot of the current tracing
      // session to be created after |stop_delay_ms| while the current tracing
      // session continues undisturbed (% an extra flush). This mode can be
      // used only when the tracing session is handled by the "dejaview" cmdline
      // client (which is true in 90% of cases). Part of the business logic
      // necessary for this behavior, and ensuing file handling, lives in
      // dejaview_cmd.cc . On other consumers, this causes only a notification
      // of the trigger through a CloneTriggerHit ObservableEvent. The custom
      // consumer is supposed to call CloneSession() itself after the event.
      // Use use_clone_snapshot_if_available=true when targeting older versions
      // of dejaview.
      CLONE_SNAPSHOT = 4;

      // NOTE: CLONE_SNAPSHOT should be used only when we targeting Android V+
      // (15+) / DejaView v38+. A bug in older versions of the tracing service
      // might cause indefinitely long tracing sessions (see b/274931668).
    }
    optional TriggerMode trigger_mode = 1;

    // This flag is really a workaround for b/274931668. This is needed only
    // when deploying configs to different versions of the tracing service.
    // When this is set to true this has the same effect of setting trigger_mode
    // to CLONE_SNAPSHOT on newer versions of the service. This boolean has been
    // introduced to allow to have configs that use CLONE_SNAPSHOT on newer
    // versions of Android and fall back to STOP_TRACING on older versions where
    // CLONE_SNAPSHOT did not exist.
    // When using this flag, trigger_mode must be set to STOP_TRACING.
    optional bool use_clone_snapshot_if_available = 5;

    // DEPRECATED, was use_clone_snapshot_if_available in U. See the comment
    // around CLONE_SNAPSHOT.
    reserved 4;

    message Trigger {
      // The producer must specify this name to activate the trigger.
      optional string name = 1;

      // An std::regex that will match the producer that can activate this
      // trigger. This is optional. If unset any producers can activate this
      // trigger.
      optional string producer_name_regex = 2;

      // After a trigger is received either in START_TRACING or STOP_TRACING
      // mode then the trace will end |stop_delay_ms| after triggering.
      // In CLONE_SNAPSHOT mode, this is the delay between the trigger and the
      // snapshot.
      // If |prefer_suspend_clock_for_duration| is set, the duration will be
      // based on wall-clock, counting also time in suspend.
      optional uint32 stop_delay_ms = 3;

      // Limits the number of traces this trigger can start/stop in a rolling
      // 24 hour window. If this field is unset or zero, no limit is applied and
      // activiation of this trigger *always* starts/stops the trace.
      optional uint32 max_per_24_h = 4;

      // A value between 0 and 1 which encodes the probability of skipping a
      // trigger with this name. This is useful for reducing the probability
      // of high-frequency triggers from dominating trace finaization. If this
      // field is unset or zero, the trigger will *never* be skipped. If this
      // field is greater than or equal to 1, this trigger will *always* be
      // skipped i.e. it will be as if this trigger was never included in the
      // first place.
      // This probability check is applied *before* any other limits. For
      // example, if |max_per_24_h| is also set, first we will check if the
      // probability bar is met and only then will we check the |max_per_24_h|
      // limit.
      optional double skip_probability = 5;
    }
    // A list of triggers which are related to this configuration. If ANY
    // trigger is seen then an action will be performed based on |trigger_mode|.
    repeated Trigger triggers = 2;

    // Required and must be positive if a TriggerConfig is specified. This is
    // how long this TraceConfig should wait for a trigger to arrive. After this
    // period of time if no trigger is seen the TracingSession will be cleaned
    // up.
    optional uint32 trigger_timeout_ms = 3;
  }
  optional TriggerConfig trigger_config = 17;

  // When this is non-empty the dejaview command line tool will ignore the rest
  // of this TraceConfig and instead connect to the dejaview service as a
  // producer and send these triggers, potentially stopping or starting traces
  // that were previous configured to use a TriggerConfig.
  repeated string activate_triggers = 18;

  // Configuration for trace contents that reference earlier trace data. For
  // example, a data source might intern strings, and emit packets containing
  // {interned id : string} pairs. Future packets from that data source can then
  // use the interned ids instead of duplicating the raw string contents. The
  // trace parser will then need to use that interning table to fully interpret
  // the rest of the trace.
  message IncrementalStateConfig {
    // If nonzero, notify eligible data sources to clear their incremental state
    // periodically, with the given period. The notification is sent only to
    // data sources that have |handles_incremental_state_clear| set in their
    // DataSourceDescriptor. The notification requests that the data source
    // stops referring to past trace contents. This is particularly useful when
    // tracing in ring buffer mode, where it is not exceptional to overwrite old
    // trace data.
    //
    // Warning: this time-based global clearing is likely to be removed in the
    // future, to be replaced with a smarter way of sending the notifications
    // only when necessary.
    optional uint32 clear_period_ms = 1;
  }
  optional IncrementalStateConfig incremental_state_config = 21;

  // Additional guardrail used by the DejaView command line client.
  // On user builds when --dropbox is set dejaview will refuse to trace unless
  // this is also set.
  // Added in Q.
  optional bool allow_user_build_tracing = 19;

  // If set the tracing service will ensure there is at most one tracing session
  // with this key.
  optional string unique_session_name = 22;

  // Compress trace with the given method. Best effort.
  enum CompressionType {
    COMPRESSION_TYPE_UNSPECIFIED = 0;
    COMPRESSION_TYPE_DEFLATE = 1;
  }
  optional CompressionType compression_type = 24;

  // DEPRECATED, was compress_from_cli.
  reserved 37;

  // Android-only. Not for general use. If set, saves the trace into an
  // incident. This field is read by dejaview_cmd, rather than the tracing
  // service. This field must be set when passing the --upload flag to
  // dejaview_cmd.
  message IncidentReportConfig {
    // In this message, either:
    //  * all of |destination_package|, |destination_class| and |privacy_level|
    //    must be set.
    //  * |skip_incidentd| must be explicitly set to true.

    optional string destination_package = 1;
    optional string destination_class = 2;
    // Level of filtering in the requested incident. See |Destination| in
    // frameworks/base/core/proto/android/privacy.proto.
    optional int32 privacy_level = 3;

    // If true, then skips saving the trace to incidentd.
    //
    // This flag is useful in testing (e.g. DejaView-statsd integration tests)
    // or when we explicitly don't want traces to go to incidentd even when they
    // usually would (e.g. configs deployed using statsd but only used for
    // inclusion in bugreports using |bugreport_score|).
    //
    // The motivation for having this flag, instead of just not setting
    // |incident_report_config|, is prevent accidents where
    // |incident_report_config| is omitted by mistake.
    optional bool skip_incidentd = 5;

    // If true, do not write the trace into dropbox (i.e. incident only).
    // Otherwise, write to both dropbox and incident.
    // TODO(lalitm): remove this field as we no longer use Dropbox.
    optional bool skip_dropbox = 4 [deprecated = true];
  }
  optional IncidentReportConfig incident_report_config = 25;

  enum StatsdLogging {
    STATSD_LOGGING_UNSPECIFIED = 0;
    STATSD_LOGGING_ENABLED = 1;
    STATSD_LOGGING_DISABLED = 2;
  }

  // Android-only. Not for general use. If specified, sets the logging to statsd
  // of guardrails and checkpoints in the tracing service. dejaview_cmd sets
  // this to enabled (if not explicitly set in the config) when specifying
  // --upload.
  optional StatsdLogging statsd_logging = 31;

  // DEPRECATED. Was trace_uuid, use trace_uuid_msb and trace_uuid_lsb instead.
  reserved 26;

  // An identifier clients can use to tie this trace to other logging.
  // DEPRECATED as per v32. See TracePacket.trace_uuid for the authoritative
  // Trace UUID. If this field is set, the tracing service will respect the
  // requested UUID (i.e. TracePacket.trace_uuid == this field) but only if
  // gap-less snapshotting is not used.
  optional int64 trace_uuid_msb = 27 [deprecated = true];
  optional int64 trace_uuid_lsb = 28 [deprecated = true];

  // When set applies a post-filter to the trace contents using the filter
  // provided. The filter is applied at ReadBuffers() time and works both in the
  // case of IPC readback and write_into_file. This filter can be generated
  // using `tools/proto_filter -s schema.proto -F filter_out.bytes` or
  // `-T filter_out.escaped_string` (for .pbtx). See go/trace-filtering for
  // design.
  //
  // Introduced in Android S, but it was broken (b/195065199). Reintroduced in
  // Android T with a different field number. Updated in Android U with a new
  // bytecode version which supports string filtering.
  message TraceFilter {
    // =========================
    // Filter bytecode.
    // =========================

    // The bytecode as implemented in Android T.
    optional bytes bytecode = 1;

    // The bytecode as implemented in Android U. Adds support for string
    // filtering.
    optional bytes bytecode_v2 = 2;

    // =========================
    // String filtering
    // =========================

    // The principles and terminology of string filtering is heavily inspired by
    // iptables. A "rule" decide how strings should be filtered. Each rule
    // contains a "policy" which indicates the algorithm to use for filtering.
    // A "chain" is a list of rules which will be sequentially checked against
    // each string.
    //
    // The first rule which applies to the string terminates filtering for that
    // string. If no rules apply, the string is left unchanged.

    // A policy specifies which algorithm should be used for filtering the
    // string.
    enum StringFilterPolicy {
      SFP_UNSPECIFIED = 0;

      // Tries to match the string field against |regex_pattern|. If it
      // matches, all matching groups are "redacted" (i.e. replaced with a
      // constant string) and filtering is terminated (i.e. no further rules are
      // checked). If it doesn't match, the string is left unchanged and the
      // next rule in chain is considered.
      SFP_MATCH_REDACT_GROUPS = 1;

      // Like |SFP_MATCH_REDACT_GROUPS| but tries to do some pre-work before
      // checking the regex. Specifically, it tries to parse the string field as
      // an atrace tracepoint and checks if the post-tgid field starts with
      // |atrace_post_tgid_starts_with|. The regex matching is only performed if
      // this check succeeds.
      SFP_ATRACE_MATCH_REDACT_GROUPS = 2;

      // Tries to match the string field against |regex_pattern|. If it
      // matches, filtering is terminated (i.e. no further rules are checked).
      // If it doesn't match, the string is left unchanged and the next rule in
      // chain is considered.
      SFP_MATCH_BREAK = 3;

      // Like |SFP_MATCH_BREAK| but tries to do some pre-work before checking
      // the regex. Specifically, it tries to parse the string field as an
      // atrace tracepoint and checks if the post-tgid field starts with
      // |atrace_post_tgid_starts_with|. The regex matching is only performed if
      // this check succeeds.
      SFP_ATRACE_MATCH_BREAK = 4;

      // Tries to repeatedly search (i.e. find substrings of) the string field
      // with |regex_pattern|. For each match, redacts any matching groups (i.e.
      // replaced with a constant string). Once there are no further matches,
      // filtering is terminated (i.e. no further rules are checked).
      //
      // Note that this is policy is a "search" policy not a "match" policy
      // unlike the above policies:
      //  * Match policies require matching the full string i.e. there is an
      //    implicit leading `^` and trailing `$`.
      //  * Search policies perform repeated partial matching of the string
      //    e.g.
      //      - String: `foo=aaa,bar=123,foo=bbb,baz=456`
      //      - Pattern: `foo=(\d+)`
      //      - Output: `foo=P6O,bar=123,foo=P6O,baz=456`
      //    where P6O is the redaction string
      //
      // All of this is only performed after some pre-work where we try to parse
      // the string field as an atrace tracepoint and check if the post-tgid
      // field starts with |atrace_post_tgid_starts_with|.
      //
      // If there are no partial matches, the string is left unchanged and the
      // next rule in chain is considered.
      SFP_ATRACE_REPEATED_SEARCH_REDACT_GROUPS = 5;
    }

    // A rule specifies how strings should be filtered.
    message StringFilterRule {
      // The policy (i.e. algorithm) dictating how strings matching this rule
      // should be handled.
      optional StringFilterPolicy policy = 1;

      // The regex pattern used to match against each string.
      optional string regex_pattern = 2;

      // The string which should appear after the tgid in atrace tracepoint
      // strings.
      optional string atrace_payload_starts_with = 3;
    }

    // A chain is a list of rules which string will be sequentially checked
    // against.
    message StringFilterChain {
      repeated StringFilterRule rules = 1;
    }
    optional StringFilterChain string_filter_chain = 3;
  }
  // old field number for trace_filter
  reserved 32;
  optional TraceFilter trace_filter = 33;

  // Android-only. Not for general use. If set, reports the trace to the
  // Android framework. This field is read by dejaview_cmd, rather than the
  // tracing service. This field must be set when passing the --upload flag to
  // dejaview_cmd.
  message AndroidReportConfig {
    // In this message, either:
    //  * |reporter_service_package| and |reporter_service_class| must be set.
    //  * |skip_reporting| must be explicitly set to true.

    optional string reporter_service_package = 1;
    optional string reporter_service_class = 2;

    // If true, then skips reporting the trace to Android framework.
    //
    // This flag is useful in testing (e.g. DejaView-statsd integration tests)
    // or when we explicitly don't want to report traces to the framework even
    // when they usually would (e.g. configs deployed using statsd but only
    // used for inclusion in bugreports using |bugreport_score|).
    //
    // The motivation for having this flag, instead of just not setting
    // |framework_report_config|, is prevent accidents where
    // |framework_report_config| is omitted by mistake.
    optional bool skip_report = 3;

    // If true, will direct the Android framework to read the data in trace
    // file and pass it to the reporter class over a pipe instead of passing
    // the file descriptor directly.
    //
    // This flag is needed because the Android test framework does not
    // currently support priv-app helper apps (in terms of SELinux) and we
    // really don't want to add an allow rule for untrusted_app to receive
    // trace fds.
    //
    // Because of this, we instead will direct the framework to create a new
    // pipe and pass this to the reporter process instead. As the pipe is
    // created by the framework, we won't have any problems with SELinux
    // (system_server is already allowed to pass pipe fds, even
    // to untrusted apps).
    //
    // As the name suggests this option *MUST* only be used for testing.
    // Note that the framework will reject (and drop) files which are too
    // large both for simplicity and to be minimize the amount of data we
    // pass to a non-priv app (note that the framework will still check
    // manifest permissions even though SELinux permissions are worked around).
    optional bool use_pipe_in_framework_for_testing = 4;
  }
  optional AndroidReportConfig android_report_config = 34;

  // If set, delays the start of tracing by a random duration. The duration is
  // chosen from a uniform distribution between the specified minimum and
  // maximum.
  // Note: this delay is implemented by dejaview_cmd *not* by traced so will
  // not work if you communicate with traced directly over the consumer API.
  // Introduced in Android T.
  message CmdTraceStartDelay {
    optional uint32 min_delay_ms = 1;
    optional uint32 max_delay_ms = 2;
  }
  optional CmdTraceStartDelay cmd_trace_start_delay = 35;

  // When non-empty, ensures that for a each semaphore named `name at most
  // `max_other_session_count`` *other* sessions (whose value is taken of the
  // minimum of all values specified by this config or any already-running
  // session) can be be running.
  //
  // If a semaphore "acquisition" fails, EnableTracing will return an error
  // and the tracing session will not be started (or elgible to start in
  // the case of deferred sessions).
  //
  // This is easiest to explain with an example. Suppose the tracing service has
  // the following active tracing sessions:
  //   S1 = [{name=foo, max_other_session_count=2},
  //         {name=bar, max_other_session_count=0}]
  //   S2 = [{name=foo, max_other_session_count=1},
  //         {name=baz, max_other_session_count=1}]
  //
  // Then, for a new session, the following would be the expected behaviour of
  // EnableSession given the state of `session_semaphores`.
  //   Q: session_semaphores = []
  //   A: Allowed because it does not specify any semaphores. Will be allowed
  //      no matter the state of any other tracing session.
  //   Q: session_semaphores = [{name=baz, max_other_session_count=1}]
  //   A: Allowed because both S2 and this config specify
  //      max_other_session_count=1 for baz.
  //   Q: session_semaphores = [{name=foo, max_other_session_count=3}]
  //   A: Denied because S2 specified max_other_session_count=1 for foo and S1
  //      takes that slot.
  //   Q: session_semaphores = [{name=bar, max_other_session_count=0}]
  //   A: Denied because S1 takes the the slot specified by both S1 and
  //      this config.
  //
  // Introduced in 24Q3 (Android V).
  message SessionSemaphore {
    // The name of the semaphore. Acts as a unique identifier across all
    // tracing sessions (including the one being started).
    optional string name = 1;

    // The maximum number of *other* sesssions which specify the same semaphore
    // which can be active. The minimum of this value across all tracing
    // sessions and the value specified by the config is used when deciding
    // whether the tracing session can be started.
    optional uint64 max_other_session_count = 2;
  }
  repeated SessionSemaphore session_semaphores = 39;
}

// End of protos/dejaview/config/trace_config.proto
